# Some nice generators
# Mostly generating integer sequences
# Inspired by 61A

# Helper functions, classes

def gcd(p, q):
	if p == q:
		return p
	elif p < q:
		return gcd(q, p)
	else:
		return gcd(p-q, q)

class Rational:
	def __init__(self, p, q):
		g = gcd(p, q)
		self.p = p // g
		self.q = q // g

	def __str__(self):
		return str(self.p)+"/"+str(self.q)

	def __repr__(self):
		return str(self)


# Generators

def intgen(n):
	yield n
	yield from integer(n)

def accumulate(gen, n=0):
	""" Let the elements generated by gen be a, b, c...
	Then accumulator(gen, n) generates n, n+a, n+a+b... """
	for elem in gen:
		yield n
		n += elem

def func(gen, f):
	""" Let the elements generated by gen be a, b, c...
	Then accumulator(gen, n) generates f(a), f(b), f(c)... """
	yield f(next(gen))
	yield from func(gen, f)


multiples = lambda n, m: accumulate(intgen(n), m)

naturals = multiples(1, 0)
evens = multiples(2, 0)
odds = func(evens, lambda x:x+1)
squares = accumulate(odds)
# or, squares = func(naturals, lambda x:x*x)

def integers():
	yield 0
	for i in naturals():
		yield i
		yield -i

def rationals():
	""" via Cantor diagonalization """
	n = 2
	while True:
		p = 1
		while p < n:
			if gcd(p, n-p) == 1:
				yield Rational(p, n-p)
			p += 1
		n += 1

def rationals_calkin_wilf():
	""" via Calkin-Wilf sequence, 
	https://www.math.upenn.edu/~wilf/website/recounting.pdf """

def rationals_calkin_wilf_closed_form(p = 1, q = 1):
	""" this formula is from Proofs by the BOOK, credited to Moshe Newman """
	yield Rational(p, q)
	yield from rationals_calkin_wilf_closed_form(q, 2*q*(p//q)-p+q)

# Integer sequences

def evens(n=0):
	for i in naturals(n//2):
		yield 2*i

def odds(n=1):
	for i in evens(n-1):
		yield i+1

def squares(n=1):
	for i in naturals(math.floor(math.sqrt(n))):
		yield i**2

def squares_by_differences(n=1):
	""" assumes n is a perfect square! """
	yield n
	yield from squares_by_differences(n+2*math.sqrt(n)+1)

def fib(a=0, b=1):
	yield a
	yield from fib(b, a+b)

def fib_alternate():
	a, b = fib(), fib()
	next(b)
	while True:
		yield next(a)+next(b)

def triangular():
	o = odds()
	i = 1
	yield i
	for odd in o:
		i += odd
		yield i

