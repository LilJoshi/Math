
# Some nice generators
# Mostly generating integer sequences
# Inspired by 61A

from operator import *
from numbertheory import is_prime


# Some nice functions
identity = lambda x: x
increment = lambda x: x+1
decrement = lambda x: x-1
double = lambda x: x+x
square = lambda x: x*x
reciprocal = lambda x: 1/x

# Some nice pure function functions
times = lambda n: lambda x: n*x

# Useful functions for generators
# map and filter, obviously

def zero():
	yield 0
	yield from zero()

def high(gen, f, n):
	""" Let the elements generated by gen be a, b, c...
	Then high(gen, f, n) generates n, f(a, n), f(b, f(a, n)), f(c, f(b, f(a, n)))... """
	yield n
	yield from high(gen, f, f(next(gen), n))

partialsums = lambda gen, n: high(gen, add, n)
partialproducts = lambda gen, n: high(gen, mul, n)
reapply = lambda n, f: high(zero(), lambda x, y: f(y), n) 
#just needed some pointless generator as first parameter
repeated = lambda n: reapply(n, identity)

# Multiple Generators

def alternate(*args):
	for i in args:
		yield(next(i))
	yield from alternate(*args)

def comb_gens(f, *args):
	yield f(*[next(i) for i in args])
	yield from comb_gens(f, *args)

add_gens = lambda *args: comb_gens(add, *args)
mul_gens = lambda *args: comb_gens(mul, *args)

#### Creating some integer sequences

arithmetic = lambda d, a: partialsums(repeated(d), a)
geometric = lambda r, a: partialproducts(repeated(r), a)

naturals = lambda: arithmetic(1, 1)
nonnegatives = lambda: arithmetic(1, 0)
negatives = lambda: arithmetic(-1, -1)
integers = lambda: alternate(nonnegatives(), negatives())
evens = lambda: arithmetic(2, 2)
odds = lambda: arithmetic(2, 1)

triangles = lambda: partialsums(naturals(), 0)
squares = lambda: partialsums(odds(), 0)
polygons = lambda n: partialsums(partialsums(n-2, 1), 0)

powers = lambda n: geometric(n, 1)
alternating = lambda: powers(-1)
#we could have also written
#squares = lambda: powers(2)

factorials = lambda: partialproducts(naturals(), 1)

harmonic = lambda: map(reciprocal, naturals())

primes = lambda: filter(is_prime, naturals())

def fibonacci(a = 0, b = 1):
	yield a
	f = fibonacci()
	yield b + next(f)
	yield from add_gens(f, fibonacci())



### Tests
def gentest(gen):
	""" for testing purposes """
	for i in range(10):
		print(next(gen))

def alltests():
	for i in [nonnegatives, negatives, integers, primes]:
		gentest(i())

alltests()


